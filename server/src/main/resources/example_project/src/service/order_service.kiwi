package service

import domain.Customer
import domain.Product
import domain.Coupon
import domain.Order
import domain.OrderStatus
import domain.OrderStatusAndTime

@Bean
class OrderService {

    static val PENDING_TIMEOUT = 15 * 60 * 1000

        fn placeOrder(customer: Customer, products: Product[], coupon: Coupon?) -> Order {
        require(products.length > 0, "Missing products")
        var price = products[0].price
        for (i in 1...products.length) {
            price = price.add(products[i].price)
        }
        if (coupon != null) {
            price = price.sub(coupon!!.redeem())
        }
        val order = Order(customer, price)
        products.forEach(p -> {
            p.reduceStock(1)
            order.Item(p, 1)
        })
        return order
    }

    fn getCustomerOrders(customer: Customer) -> Order[] {
        val orders = Order.customerIdx.getAll(customer)
        // Recent orders come first
        orders.sort((o1, o2) -> o1.createdAt < o2.createdAt ? 1 : o1.createdAt == o2.createdAt ? 0 : -1)
        return orders
    }

        fn confirmOrder(order: Order) {
        order.confirm()
    }

        fn confirmOrder(order: Order) {
        order.cancel()
    }

        fn cancelExpiredPendingOrders() {
        val orders = Order.statusAndCreatedAtIdx.query(
            OrderStatusAndTime(OrderStatus.PENDING, 0),
            OrderStatusAndTime(OrderStatus.PENDING, now() - PENDING_TIMEOUT)
        )
        orders.forEach(o -> o.cancel())
    }

        fn deleteAllCancelledOrders() {
        val orders = Order.statusAndCreatedAtIdx.query(
            OrderStatusAndTime(OrderStatus.CANCELLED, 0),
            OrderStatusAndTime(OrderStatus.CANCELLED, now())
        )
        orders.forEach(o -> {
            delete o
        })
    }

    fn deleteAllCustomerOrders(customer: Customer) {
        val orders = Order.customerIdx.getAll(customer)
        orders.forEach(o -> {
            delete o
        })
    }

}
