class Exchange(
    val user: User,
    @Tag(1000001)
    val app: Application,
    val prompt: string,
    val first: bool,
    var skipPageGeneration: bool
) {

    var status = ExchangeStatus.PLANNING

    var productURL: string?
    var managementURL: string?

    var errorMessage: string?

    var lastHeartBeatAt = now()

    static val appIdx = Index<Application, Exchange>(false, exch -> exch.app)

    static val statusAndLastHeartBeatAtIdx = Index<RunningAndTimestamp, Exchange>(false, exch -> RunningAndTimestamp(exch.isRunning(), exch.lastHeartBeatAt))

    class Stage(val type: StageType) {

        var status = StageStatus.GENERATING

        class Attempt {
            var status = AttemptStatus.RUNNING
            var errorMessage: string?
        }

    }

    fn __lastHeartBeat__() -> long {
        return now()
    }

    fn sendHeartBeat() {
        require(isRunning(), "Cannot send heartbeat for a non-running exchange")
        lastHeartBeatAt = now()
    }

    fn cancel() {
        if (!isRunning())
            throw Exception("Cannot cancel a non-running exchange")
        status = ExchangeStatus.CANCELLED
    }

    fn isRunning() -> bool {
        return status == ExchangeStatus.GENERATING || status == ExchangeStatus.PLANNING
    }

    fn retry() {
        if (status != ExchangeStatus.FAILED)
            throw Exception("Cannot retry a non-failed exchange")
        status = ExchangeStatus.PLANNING
        lastHeartBeatAt = now()
    }

    fn revert() {
        if (status == ExchangeStatus.REVERTED)
            throw Exception("Cannot revert an already reverted exchange")
        if (isRunning())
            throw Exception("Cannot revert a running exchange")
        status = ExchangeStatus.REVERTED
    }

    fn fail(errMsg: string) {
        require(isRunning(), "Cannot fail a non-running exchange: " + prompt)
        status = ExchangeStatus.FAILED
        errorMessage = errMsg
        for (c in children) {
            if (c is Stage stage && stage.status == StageStatus.GENERATING) {
                stage.status = StageStatus.FAILED
                for (c2 in stage.children) {
                    if (c2 is Stage.Attempt attempt && attempt.status == AttemptStatus.RUNNING)
                        attempt.status = AttemptStatus.FAILED
                }
            }
        }
    }

    fn hasSuccessfulStages() -> bool {
        for (c in children) {
            if (c is Stage stage && stage.status == StageStatus.SUCCESSFUL)
                return true
        }
        return false
    }

}

value class RunningAndTimestamp(val running: bool, val timestamp: long)

@Bean
class ExchangeService {

    static val TIMEOUT = 60000

    fn failExpiredExchanges() -> Exchange[] {
        val expired = Exchange.statusAndLastHeartBeatAtIdx.query(
            RunningAndTimestamp(true, 0),
            RunningAndTimestamp(true, now() - TIMEOUT)
        )
        for (exch in expired) {
            exch.fail("Timeout")
        }
        return expired
    }

    fn revertExchange(exchange: Exchange) {
        if (exchange != Exchange.appIdx.getLast(exchange.app))
            throw Exception("Cannot revert an exchange that is not the last one for the application")
        exchange.revert()
    }

    fn isGenerating(app: Application) -> bool {
        val exch = Exchange.appIdx.getLast(app)
        return exch != null && exch!!.isRunning()
    }

}


enum ExchangeStatus {
    PLANNING,
    GENERATING,
    SUCCESSFUL,
    FAILED,
    CANCELLED,
    REVERTED,
;
}


enum StageType {
    BACKEND,
    FRONTEND,
    ;
}

enum StageStatus {
    GENERATING,
    COMMITTING,
    SUCCESSFUL,
    FAILED
    ;
}

enum AttemptStatus {
    RUNNING,
    SUCCESSFUL,
    FAILED;
}
